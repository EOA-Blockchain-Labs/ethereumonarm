#!/bin/bash
# This script sets up an Ethereum node on a small computer.
# It runs automatically one time when the computer starts.

# This file helps the script know if it ran before.
FLAG="/root/first-run.flag"

# If the flag file exists, setup is done, so we stop.
if [ -f "$FLAG" ]; then
    echo "Setup already finished. Stopping."
    exit 0
fi

# How long to wait for the internet (in seconds).
WAIT_TIME=20

# Wait for network connection.
echo "Waiting for network..."
sleep "$WAIT_TIME"

# Check if internet works.
echo "Checking internet..."
if ! wget -q -t 1 --timeout=30 --spider http://github.com; then
    echo "No internet. Cannot continue setup."
    exit 1
fi
echo "Internet OK."

# --- Find computer type ---
echo "Finding computer model..."
DEVICE_MODEL=$(cat /sys/firmware/devicetree/base/model 2>/dev/null || uname -m | tr -d '\\0')
echo "Model: $DEVICE_MODEL"

# Set settings based on computer model.
case "$DEVICE_MODEL" in
"Raspberry Pi 5 Model B Rev 1.1")
    TARGET_DISK="/dev/nvme0n1" # Hard drive for data
    PARTITION1="p1"            # Part of the drive to use
    HOSTNAME_SEED="rpi5"       # Part of computer name
    SWAP_SIZE=8192             # Extra memory space (MB)
    SWAPPINESS=1               # How much to use extra memory
    ;;

"FriendlyElec NanoPC-T6")
    TARGET_DISK="/dev/nvme0n1" # Hard drive for data
    PARTITION1="p1"            # Part of the drive to use
    HOSTNAME_SEED="nanopct6"   # Part of computer name
    SWAP_SIZE=8192             # Extra memory space (MB)
    SWAPPINESS=1               # How much to use extra memory
    ;;

"Radxa ROCK 5B")
    TARGET_DISK="/dev/nvme0n1" # Hard drive for data
    PARTITION1="p1"            # Part of the drive to use
    HOSTNAME_SEED="rock5b"     # Part of computer name
    SWAP_SIZE=8192             # Extra memory space (MB)
    SWAPPINESS=1               # How much to use extra memory
    ;;

"Orange Pi 5 Plus" | "Xunlong Orange Pi 5 Plus")
    TARGET_DISK="/dev/nvme0n1" # Hard drive for data
    PARTITION1="p1"            # Part of the drive to use
    HOSTNAME_SEED="opi5plus"   # Part of computer name
    SWAP_SIZE=8192             # Extra memory space (MB)
    SWAPPINESS=1               # How much to use extra memory
    ;;

*)
    echo "Unknown computer model: $DEVICE_MODEL. Stopping."
    exit 1
    ;;
esac
echo "Disk=${TARGET_DISK}, Partition=${PARTITION1}, Name part=${HOSTNAME_SEED}"

# --- Lists of software to install ---
BASE_PACKAGES="apt-utils bash-completion file gdisk gpg parted net-tools rsync software-properties-common ufw vim wget kitty-terminfo"
ETHEREUM_PACKAGES="arbitrum-nitro besu dvt-obol erigon ethstaker-deposit-cli ethereumonarm-utils fuel-network geth lighthouse lodestar ls-lido mev-boost nethermind nimbus optimism-op-geth optimism-op-node prysm reth starknet-juno teku"
MONITORING_PACKAGES="ethereumonarm-monitoring-extras grafana prometheus prometheus-node-exporter"
NGINX_PACKAGES="ethereumonarm-config-sync ethereumonarm-nginx-proxy-extras ethereumonarm-utils nginx"

# --- Tune ntp daemon ---

# Create directory for systemd-timesyncd drop-in config if it doesn't exist
sudo mkdir -p /etc/systemd/timesyncd.conf.d/

# Write the NTP configuration to eoa.conf
sudo tee /etc/systemd/timesyncd.conf.d/eoa.conf >/dev/null <<EOF
# Configuration to improve time sync accuracy using Google's NTP servers.
# systemd-timesyncd is a simple NTP client included with systemd that syncs the system clock.
# This config sets multiple NTP servers and adjusts polling intervals to reduce time drift,
# helping maintain accurate system time which is important for services like Ethereum validators.

[Time]
NTP=time1.google.com time2.google.com time3.google.com time4.google.com
PollIntervalMinSec=16
PollIntervalMaxSec=64
RootDistanceMaxSec=100
EOF

# Enable NTP synchronization
sudo timedatectl set-ntp true

# Restart systemd-timesyncd to apply changes
sudo systemctl restart systemd-timesyncd

# --- Install Basic Programs ---
echo "Cleaning posible outdated cache"
apt-get clean all
echo "Getting program list..."
apt-get update || {
    echo "Failed to get program list."
    exit 1
}
echo "Installing basic programs..."
apt-get -y install $BASE_PACKAGES || {
    echo "Failed to install basic programs."
    exit 1
}
echo "Basic programs installed."

# --- Add new places to get programs and update list ---
echo "Adding Ethereum on ARM programs list..."
wget -qO- http://apt.ethereumonarm.com/eoa.apt.keyring.gpg | tee /etc/apt/trusted.gpg.d/eoa.gpg >/dev/null
add-apt-repository -y -n "deb http://apt.ethereumonarm.com noble main" || {
    echo "Failed to add Ethereum on ARM list."
    exit 1
}

echo "Adding Grafana programs list..."
wget -q -O - https://packages.grafana.com/gpg.key | gpg --dearmor | tee /etc/apt/trusted.gpg.d/grafana.gpg >/dev/null
echo "deb https://packages.grafana.com/oss/deb stable main" | tee /etc/apt/sources.list.d/grafana.list || {
    echo "Failed to add Grafana list."
    exit 1
}

# Get the newest program list from all places.
echo "Getting newest program list..."
apt-get update || {
    echo "Failed to get newest program list."
    exit 1
}

# --- Prepare the hard drive ---

# This job prepares the hard drive. IT WILL ERASE EVERYTHING!
# Includes a check for a .format_me file to allow re-formatting an existing /home/ethereum
format_disk() {
    local DISK="$1"
    local PART_DEVICE="${DISK}${PARTITION1}"
    local PROCEED_WITH_FORMAT=false

    echo "Preparing disk ${DISK}. DANGER: All data will be lost UNLESS /home/ethereum exists AND .format_me is NOT present!"

    # Check if the partition exists and contains a Linux filesystem
    if [[ -b "$PART_DEVICE" && $(file -s "$PART_DEVICE" | grep -oP 'Linux.*filesystem') ]]; then
        TMP_DIR=$(mktemp -d)
        echo "Attempting to mount ${PART_DEVICE} to check for /home/ethereum..."
        if mount "$PART_DEVICE" "$TMP_DIR"; then
            if [ -d "$TMP_DIR/ethereum" ]; then
                echo "/home/ethereum already exists on the disk."
                if [ -f "$TMP_DIR/ethereum/.format_me" ]; then
                    echo "The .format_me file was found in /home/ethereum. Proceeding with formatting."
                    PROCEED_WITH_FORMAT=true
                else
                    echo "The .format_me file was not found in /home/ethereum. Skipping format and mount."
                    PROCEED_WITH_FORMAT=false
                fi
            else
                echo "The path /home/ethereum does not exist on the disk. Proceeding with formatting."
                PROCEED_WITH_FORMAT=true
            fi
            # Unmount the disk from the temporary directory
            if mountpoint -q "$TMP_DIR"; then
                umount "$TMP_DIR"
            fi
        else
            echo "Could not mount ${PART_DEVICE}. Proceeding with formatting."
            PROCEED_WITH_FORMAT=true
        fi
        # Clean up temporary directory
        if [ -d "$TMP_DIR" ]; then
            rm -r "$TMP_DIR"
        fi
    else
        echo "Partition ${PART_DEVICE} does not exist or is not a Linux filesystem. Proceeding with formatting."
        PROCEED_WITH_FORMAT=true
    fi

    if [ "$PROCEED_WITH_FORMAT" = true ]; then
        echo "Trying to stop using parts of ${DISK}..."
        umount "${PART_DEVICE}" 2>/dev/null || echo "Info: Part not used or couldn't stop."
        lsblk -nrpo NAME,MOUNTPOINT "${DISK}" | awk '$2!=""{print $1}' | xargs -r -n1 umount 2>/dev/null || echo "Info: No other parts used or couldn't stop."
        sleep 2

        echo "Cleaning old info on ${DISK}..."
        wipefs --all --force "${DISK}" || {
            echo "Failed to clean ${DISK}"
            return 1
        }

        echo "Creating new structure and part on ${DISK}..."
        echo "label: gpt" | sfdisk --force --no-reread "${DISK}" || {
            echo "Failed to create structure."
            return 1
        }
        echo ",,L" | sfdisk --append --force --no-reread "${DISK}" || {
            echo "Failed to create part."
            return 1
        }

        echo "Waiting for computer to see new part ${PART_DEVICE}..."
        sleep 5
        partprobe "${DISK}" || echo "partprobe did nothing or failed."

        echo "Helping computer see the new part..."
        udevadm trigger --action=add --subsystem-match=block || echo "udevadm trigger failed."
        echo "Waiting for computer to finish."
        udevadm settle || echo "udevadm settle failed."
        sleep 2

        if [ ! -b "${PART_DEVICE}" ]; then
            echo "Warning: Part ${PART_DEVICE} not seen. Waiting more..."
            sleep 15
            partprobe "${DISK}" || echo "partprobe did nothing or failed."
            udevadm trigger --action=add --subsystem-match=block || echo "udevadm trigger failed."
            udevadm settle || echo "udevadm settle failed."
            sleep 2

            if [ ! -b "${PART_DEVICE}" ]; then
                echo "Error: Part ${PART_DEVICE} still not found. Stopping disk setup."
                return 1
            fi
            echo "Part ${PART_DEVICE} found after waiting."
        fi

        echo "Making ${PART_DEVICE} ready to store files (formatting)..."
        if mountpoint -q "${PART_DEVICE}"; then
            echo "Warning: ${PART_DEVICE} is used. Trying to stop..."
            umount "${PART_DEVICE}" || {
                echo "Failed to stop using ${PART_DEVICE}."
                return 1
            }
            sleep 1
        fi
        mkfs.ext4 -F -L "ethereum_data" "${PART_DEVICE}" || {
            echo "Failed to format ${PART_DEVICE}"
            return 1
        }

        echo "Disk ${DISK} ready."
        return 0
    else
        echo "Skipping disk format as requested by .format_me check."
        return 0 # Return 0 even if formatting is skipped, as it's an intended path
    fi
}

# Start preparing the hard drive. Stop if it fails.
echo "Starting disk preparation..."
format_disk "$TARGET_DISK" || exit 1
echo "Disk preparation done."

# Set empty space on the drive part to 0%.
echo "Setting empty space on ${TARGET_DISK}${PARTITION1} to 0%..."
tune2fs -m 0 "${TARGET_DISK}${PARTITION1}"

# Tell the computer to use this drive part for /home.
echo "Adding /home to mount list..."
sed -i '\|^.*/home.*|d' /etc/fstab # Remove old /home line
echo "${TARGET_DISK}${PARTITION1} /home ext4 defaults,noatime 0 2" >>/etc/fstab
echo "Mounting /home..."
systemctl daemon-reload # Apply changes
mount /home || {        # Use /home now
    echo "Failed to mount /home. Check settings and disk."
    exit 1
}
systemctl daemon-reload # Apply changes again

# --- Set up a user for Ethereum ---
echo "Setting up 'ethereum' user..."
if ! id -u ethereum >/dev/null 2>&1; then
    echo "Creating 'ethereum' user..."
    adduser --disabled-password --gecos "" ethereum
    echo "Setting initial password (must change on first login)..."
    echo "ethereum:ethereum" | chpasswd
    chage -d 0 ethereum # User must change password
fi

echo "Adding 'ethereum' user to groups..."
for GRP in sudo netdev audio video dialout plugdev; do
    adduser ethereum "$GRP"
done

echo "Granting passwordless sudo to 'ethereum' user..."

SUDOERS_FILE="/etc/sudoers.d/90-ethereum-nopasswd"
# Create the sudoers file content
# Allows user 'ethereum' to run any command as any user ('ALL=(ALL)') without a password ('NOPASSWD: ALL')
echo "ethereum ALL=(ALL) NOPASSWD: ALL" >"$SUDOERS_FILE" || {
    echo "Failed to create sudoers file for ethereum."
}
# Set correct permissions (read-only for root) - sudo ignores files with insecure permissions
chmod 0440 "$SUDOERS_FILE" || {
    echo "Failed to set permissions on sudoers file for ethereum."

    rm -f "$SUDOERS_FILE"
}
echo "Passwordless sudo configured."

echo "'ethereum' user setup complete."

# --- Set up extra memory space (Swap) ---
echo "Setting up swap..."
SWAP_FILE="/home/ethereum/swapfile" # Swap file location
# Generate escaped unit name from swap file path
SWAP_UNIT=$(systemd-escape -p --suffix=swap "$SWAP_FILE")

echo "Creating folder /home/ethereum if needed..."
mkdir -p /home/ethereum
chown ethereum:ethereum /home/ethereum # ethereum user owns folder

echo "Making swap file ${SWAP_FILE} (${SWAP_SIZE}M)..."
# Check if swap file exists and remove it before creating a new one
if [ -f "${SWAP_FILE}" ]; then
    echo "Existing swap file found. Removing it."
    swapoff "${SWAP_FILE}" 2>/dev/null
    rm "${SWAP_FILE}"
fi
fallocate -l "${SWAP_SIZE}M" "${SWAP_FILE}" || {
    echo "Failed to make swap file. Check disk space."
    exit 1
}

echo "Making swap file ready..."
chmod 600 "${SWAP_FILE}"
mkswap "${SWAP_FILE}" || {
    echo "Failed to make swap file ready."
    exit 1
}

# Create systemd swap unit with proper naming
echo "Creating systemd unit: ${SWAP_UNIT}"
cat <<EOF >/etc/systemd/system/"${SWAP_UNIT}"
[Unit]
Description=Swap File at ${SWAP_FILE}

[Swap]
What=${SWAP_FILE}
Priority=10

[Install]
WantedBy=multi-user.target
EOF

echo "Enabling and activating swap..."
systemctl daemon-reload
systemctl enable --now "${SWAP_UNIT}" || {
    echo "Failed to enable/start swap. Check system settings."
    exit 1
}

echo "Verifying swap..."
swapon --show
echo "Swap setup completed successfully."

# --- Set computer name and network ---
echo "Setting up computer name..."
ACTIVE_INTERFACE=$(ip route get 8.8.8.8 | awk '/dev/ {print $5; exit}')
if [ -z "$ACTIVE_INTERFACE" ]; then
    echo "Could not find network name. Skipping name setup."
else
    echo "Network: $ACTIVE_INTERFACE"
    MAC_ADDRESS=$(cat /sys/class/net/"$ACTIVE_INTERFACE"/address)
    if [ -n "$MAC_ADDRESS" ]; then
        echo "Network number: $MAC_ADDRESS"
        MAC_HASH=$(echo "$MAC_ADDRESS" | sha256sum | cut -c1-8)
        NEW_HOSTNAME="ethereumonarm-${HOSTNAME_SEED}-${MAC_HASH}"
        echo "Setting name to $NEW_HOSTNAME..."
        echo "$NEW_HOSTNAME" >/etc/hostname
        hostnamectl set-hostname "$NEW_HOSTNAME"
        sed -i "s/127\.0\.1\.1.*/127.0.1.1	$NEW_HOSTNAME/g" /etc/hosts
        echo "Computer name setup done."
    else
        echo "Could not find network number. Skipping name setup."
    fi
fi

# --- Make computer run better ---
echo "Making computer run better..."
if [[ -f /etc/default/armbian-zram-config ]]; then
    echo "Turning off Armbian zRAM..."
    sed -i "s/ENABLED=true/ENABLED=false/g" /etc/default/armbian-zram-config
fi
echo "Setting how much to use swap to ${SWAPPINESS}..."
sed -i '/^vm\.swappiness/d' /etc/sysctl.conf # Remove old setting
echo "vm.swappiness=${SWAPPINESS}" >>/etc/sysctl.conf
sysctl -p # Apply settings now
echo "Performance settings applied."

# --- Install Ethereum Programs ---
echo "Installing Ethereum programs..."
apt-get -y install $ETHEREUM_PACKAGES || {
    echo "Failed to install Ethereum programs."
    exit 1
}
echo "Ethereum programs installed."

# Add info about the Ethereum on ARM version.
echo "Setting Ethereum on ARM version info..."
EOA_RELEASE_FILE="/etc/eoa-release"
EOA_MINOR_VERSION=${EOA_MINOR_VERSION:-0}
EOA_MAJOR_VERSION=$(date +"%y"."%m")
EOA_VERSION="Ethereum on ARM $EOA_MAJOR_VERSION.$EOA_MINOR_VERSION"
echo "$EOA_VERSION" >"$EOA_RELEASE_FILE"

# --- Add a shortcut command for updating Ethereum programs ---
echo "Adding update shortcut 'update-ethereum'..."
sed -i '/^alias update-ethereum=/d' /etc/bash.bashrc # Remove old shortcut
cat <<EOF >>/etc/bash.bashrc

# Shortcut to update Ethereum on ARM programs
alias update-ethereum='sudo apt-get update && sudo apt-get install $ETHEREUM_PACKAGES'
EOF
# Make sure the computer sees this shortcut for all users.
grep -q "if \[ -f /etc/bash.bashrc \]; then . /etc/bash.bashrc; fi" /etc/profile ||
    echo "if [ -f /etc/bash.bashrc ]; then . /etc/bash.bashrc; fi" >>/etc/profile

# --- Set up Programs to Watch the Node ---
echo "Setting up watching programs (Grafana, Prometheus)..."

echo "Making sure user 'prometheus' exists..."
if ! id -u prometheus >/dev/null 2>&1; then
    adduser --quiet --system --home /home/prometheus --no-create-home --group --gecos "Prometheus daemon" prometheus
fi
mkdir -p /home/prometheus/{metrics2,node-exporter}                       # Make folders
chown -R prometheus:prometheus /home/prometheus/{metrics2,node-exporter} # prometheus user owns folders

echo "Installing watching programs..."
apt-get -y install $MONITORING_PACKAGES || {
    echo "Failed to install watching programs."
    exit 1
}

echo "Turning on watching services..."
systemctl enable grafana-server
systemctl enable prometheus prometheus-node-exporter

echo "Applying special settings for watching programs..."
set-ethereumonarm-monitoring-extras -o || echo "Warning: Failed to apply watching settings."
systemctl daemon-reload
echo "Watching programs setup done."

# --- Set up Nginx (for web access) ---
echo "Setting up Nginx..."
echo "Installing Nginx programs..."
apt-get -y install $NGINX_PACKAGES || {
    echo "Failed to install Nginx programs."
    exit 1
}
echo "Turning on Nginx service..."
systemctl enable nginx
echo "Nginx setup done."

# --- Restore clients configuration if a previous one exists ---
echo "Checking for existing client configurations to restore..."
if [ -d "/home/ethereum/.etc/ethereum/" ]; then
    echo "Found existing configurations. Restoring..."
    rsync --min-size=1 -avz "/home/ethereum/.etc/ethereum/" "/etc/ethereum/"
    echo "Client configurations restored."
else
    echo "No existing client configurations found to restore."
fi

# --- Make computer more secure ---
echo "Making computer more secure..."
echo "Blocking 'root' login..."
passwd -l root

# --- Clean up: Remove other users ---
UID_MIN=$(awk '/^UID_MIN/{print $2}' /etc/login.defs)
UID_MAX=$(awk '/^UID_MAX/ {print $2}' /etc/login.defs)

echo "Removing other users (except 'ethereum')..."
awk -F: -v min="$UID_MIN" -v max="$UID_MAX" '{if($3 >= min && $3 <= max && $1 != "ethereum") print $1}' /etc/passwd | xargs -r deluser --remove-home || echo "Warning: Could not remove all other users."

# --- Fix permissions for ethereum home folder ---
echo "Fixing permissions for /home/ethereum..."
chown -R ethereum:ethereum /home/ethereum/

# --- Turn off firewall (ufw) ---
echo "Turning off UFW firewall..."
ufw --force disable

# --- Finish Setup and Restart ---
echo "Setup done. Creating flag file and restarting."
touch "$FLAG"
# Add info about this script run to the flag file.
grep "rc.local" /var/log/syslog >>"$FLAG"

sync && sleep 3 && reboot # Restart the computer

exit 0 # Script finished OK.
